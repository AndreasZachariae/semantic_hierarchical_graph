import random
import networkx as nx
import numpy as np
import math
import time


class IPSmoothing:
    """
    Smoothing algorithm and helper functions

    :param graph: Stores the generated graph from result
    :param solution: Stores the original solution from result, which is generated by the planner
    :param collision_checker: Stores information about obstables allowing for collision checks
    :param length_history: A list storing the overall length of the path for each iteration
    :param debug: Boolean, enables or disables the printed output of debug information and iterative plots of each
    smoothing step. (default False)
    """
    statistics = []

    def __init__(self, graph, path, collision_checker):
        self.graph = graph
        self.original_path = path
        self.collision_checker = collision_checker
        self.length_history = []
        self.debug = False

    def smooth_solution(self, max_iterations, k_max, eps=0, variance_window=0, min_variance=0):
        """
        Smooths the path solution over a range of iterations, breaking if the range count is exceeded, or if the path
        variance is smaller than a minimum value.

        Selects a random point (P) on the path, then attempts to smooth the path by connecting the points (P-k_max) and
        (P+k_max) directly, if successful, all points between are deleted. By failure, k is de-incremented and the new
        points checked for connection. After repeated failure, and k=1, then delTree is called. Returns the smoothed
        path as an NetworkX Graph object.

        :param k_max: k value for selecting the predecessor and follower points to be joined
        :param eps: epsilon value for input into delTree
        :param variance_steps: window width for the rolling variance, how many previous iterations should be considered
        :param min_variance: minimum value for the variance, used to end the process early when path change is minimal
        :param debug: Boolean check to enable/disable printed information. (default False)
        :return: smooth_graph -- NetworkX Graph object containing the improved path
        """

        start_time = time.time()

        if self.original_path is None or len(self.original_path) <= 2:
            return self.original_path, self.graph

        smooth_graph = nx.Graph(nx.subgraph(self.graph, self.original_path))
        pos = nx.get_node_attributes(smooth_graph, 'pos')
        path = self.original_path.copy()
        self.length_history.append(self.get_path_length(pos, path))

        for n in range(max_iterations):
            # if n > variance_window:
            #     rolling_var = np.var(self.length_history[-variance_window:])
            #     print(f"Variance: {rolling_var}")
            #     print(len(self.length_history[-variance_window:]))
            #     # print("Size: ", len(path))
            #     print("Length: ", self.length_history[-1])
            #     if rolling_var <= min_variance:
            #         print(f"Variance: {rolling_var}, num of iterations: {n}")
            #         print("Breaking due to small variance")
            #         break

            if len(path) <= 2:
                break

            node_in_collision = []
            # i = random.randint(1, len(path)-1)
            node_generator = self.get_next_worst_node(path, pos)
            for i in node_generator:
                i = node_generator.send(node_in_collision)  # type: ignore
                if i is None:
                    continue
                # print("worst", i, "/", len(path))
                k_max = min(k_max, len(path)-2)

                collision = self.decrease_k_until_connection(i, k_max, path, smooth_graph, pos)

                if collision is None:
                    path = nx.shortest_path(smooth_graph, "start", "goal")
                    break
                else:
                    node_in_collision.append(i)

            else:
                # All nodes are at lowest k in collision. Break outer iterations.
                # print("Break smoothing", n)
                break

            self.length_history.append(self.get_path_length(pos, path))

        end_time = time.time()
        # print("Smoothing time", end_time - start_time)

        return path, self.graph

    def decrease_k_until_connection(self, i, k_max, path, smooth_graph, pos):
        for k in range(k_max, 0, -1):
            if i-k <= 0:
                k_prev_node = "start"
            else:
                k_prev_node = path[i-k]

            if i+k >= len(path)-1:
                k_next_node = "goal"
            else:
                k_next_node = path[i+k]

            if self.debug:
                print(f"Initial Path: {path}")
                print(f"edges: {smooth_graph.edges}")
                print(f"K: {k}")
                print(f"i: {i}")
                print(f"length of path: {len(path)}")
                print(f"k_prev: {k_prev_node}")
                print(f"Centered: {path[i]}")
                print(f"k_next: {k_next_node}")

            if self.collision_checker.lineInCollision(pos[k_prev_node], pos[k_next_node]):
                if self.debug:
                    print("Line collides, No change")

            else:
                smooth_graph.add_edge(k_prev_node, k_next_node)

                between_nodes = path[path.index(k_prev_node)+1:path.index(k_next_node)]

                for node in between_nodes:
                    smooth_graph.remove_node(node)

                if self.debug:
                    print("new edge (", k_prev_node, "-", k_next_node, ") k =", k, " remove:", between_nodes)
                    print(f'New path: {path}')

                return None

        # TODO: If no connection can be found and last check is in collision.
        # Do the delTree method to generate new smaller path segments.

        # if k == 1 and iscolliding and not break_loop:
        #     smooth_graph = self.del_tree(smooth_graph, path, eps, i)

        return i

    def get_next_worst_node(self, path, pos):
        prioList = []

        # Berechne alle Knotentripel
        for i in range(1, len(path)-1):
            P1 = pos[path[i-1]]
            P2 = pos[path[i]]
            P3 = pos[path[i+1]]

            # Berechnung der jeweiligen AbstÃ¤nde der Punkte
            d12 = self.distance(P1, P2)
            d23 = self.distance(P2, P3)
            d13 = self.distance(P1, P3)

            # Berechnung der Bewertungskennzahl
            Q = (d12+d23)/d13
            prioList.append([i, path[i], Q])

        # Sortiere die Liste nach der Bewertungskennzahl
        prioList.sort(key=lambda x: x[2], reverse=True)
        node_in_collision = []
        for node in prioList:
            node_in_collision = yield
            # print("Node in collision:", node_in_collision)
            equal_worsts = [i for i in prioList if (i[2] == node[2] and i[0] not in node_in_collision)]
            if len(equal_worsts) == 0:
                yield None
            random.shuffle(equal_worsts)
            # print([n[0] for n in equal_worsts])
            for e in equal_worsts:
                if equal_worsts.index(e) > 0:
                    not_used = yield
                yield e[0]

    def del_tree(self, graph, path, eps, center_index):
        """
        Smooths the path when pre-existing points cannot be directly joined. Generates new midpoints along the paths
        between points (P) and (P-1) or (P+1). Attempts to join the midpoints directly and delete (P). If this fails,
        then a new attempt is made with a new set of midpoints, closer to (P). Repeats until successful, or until the
        distance between (P) and the new midpoints is smaller than a user-defined value, eps. Returns a NetworkX Graph
        object, graph.

        :param graph: A NetworkX Graph object to be smoothed
        :param path: NetworkX Union object containing the shortest path between Start and Goal
        :param eps: Shortest allowable distance between centerpoint (P) and the generated midpoint.
        :param center_index: Index of centerpoint (P)
        :return: graph -- NetworkX Graph object containing the improved path
        """
        DT_Flag = True
        t = 1

        # Gather the points
        k_prev_node = path[center_index-1]
        center_node = path[center_index]
        k_next_node = path[center_index+1]

        if self.debug:
            print(f"DelTree centered on list item {center_index}, node: {path[center_index]}")

        pA = np.array(graph.nodes[k_prev_node]['pos'])
        pB = np.array(graph.nodes[center_node]['pos'])
        pC = np.array(graph.nodes[k_next_node]['pos'])

        # Calculate distance
        dAB = pA - pB
        dCB = pC - pB

        while DT_Flag:
            pD = pB + dAB/pow(2, t)  # Pz1 from slides
            pE = pB + dCB/pow(2, t)  # Pz2 from slides

            # if magnitude/2^t is smaller than eps, break loop
            if np.linalg.norm(dAB)/pow(2, t) < eps or np.linalg.norm(dCB)/pow(2, t) < eps:
                if self.debug:
                    print("DelTree failed, line value smaller than epsilon")

                DT_Flag = False

            # Test line connection between new points for collisions
            elif not self.collision_checker.lineInCollision(pD, pE):

                DT_Flag = False  # Breaks while loop

                highest_node_name = max([i for i in graph.nodes if isinstance(i, int)])
                if self.debug:
                    print(f"graph nodes: {graph.nodes}")
                    print(highest_node_name)

                new_id1 = highest_node_name+1
                new_id2 = highest_node_name+2

                graph.add_node(new_id1, pos=pD.tolist())  # Add new Nodes
                graph.add_node(new_id2, pos=pE.tolist())

                graph.add_edge(k_prev_node, new_id1)  # Add new Edges
                graph.add_edge(new_id1, new_id2)
                graph.add_edge(new_id2, k_next_node)

                graph.remove_node(center_node)  # Delete corner node

                if self.debug:
                    print(f"Adding nodes: {new_id1} and {new_id2}")
                    print(f"deleting center node: {center_node}")
                    print("DelTree successful")
                    path = nx.shortest_path(graph, "start", "goal")
                    print(f'del_tree path creation, new path: {path}')

            else:
                if self.debug:
                    print("DelTree line collides")

            path = nx.shortest_path(graph, "start", "goal")
            self.length_history.append(self.get_path_length(nx.get_node_attributes(graph, 'pos'), path))

            t += 1

        return graph

    def get_path_length(self, pos, solution):
        """
        Calculates the length of the path based on each node's position. Returns length.

        :param pos: Dict with each node's position
        :param solution: the solution path to be checked
        :return: length -- the length of the solution path
        """

        prev_node = None
        length = 0

        for node in solution:
            if prev_node is not None:
                length += self.distance(pos[node], pos[prev_node])
            prev_node = node

        return length

    def distance(self, point_1, point_2):
        distance = math.sqrt(math.pow(point_1[0]-point_2[0], 2) + math.pow(point_1[1]-point_2[1], 2))
        return distance
